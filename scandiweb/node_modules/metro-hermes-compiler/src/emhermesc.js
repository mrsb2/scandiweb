"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @generated
 */ /* eslint-disable */ var createHermesc = (function () {
  var _scriptDir =
    typeof document !== "undefined" && document.currentScript
      ? document.currentScript.src
      : undefined;
  if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
  return function (createHermesc) {
    createHermesc = createHermesc || {};
    var Module = typeof createHermesc !== "undefined" ? createHermesc : {};
    var readyPromiseResolve, readyPromiseReject;
    Module["ready"] = new Promise(function (resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var moduleOverrides = {};
    var key;
    for (key in Module) {
      if (Module.hasOwnProperty(key)) {
        moduleOverrides[key] = Module[key];
      }
    }
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = function (status, toThrow) {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = true;
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_, readBinary;
    var nodeFS;
    var nodePath;
    if (ENVIRONMENT_IS_NODE) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = require("path").dirname(scriptDirectory) + "/";
      } else {
        scriptDirectory = __dirname + "/";
      }
      read_ = function shell_read(filename, binary) {
        var ret = tryParseAsDataURI(filename);
        if (ret) {
          return binary ? ret : ret.toString();
        }
        if (!nodeFS) nodeFS = require("fs");
        if (!nodePath) nodePath = require("path");
        filename = nodePath["normalize"](filename);
        return nodeFS["readFileSync"](filename, binary ? null : "utf8");
      };
      readBinary = function readBinary(filename) {
        var ret = read_(filename, true);
        if (!ret.buffer) {
          ret = new Uint8Array(ret);
        }
        assert(ret.buffer);
        return ret;
      };
      if (process["argv"].length > 1) {
        thisProgram = process["argv"][1].replace(/\\/g, "/");
      }
      arguments_ = process["argv"].slice(2);
      process["on"]("uncaughtException", function (ex) {
        if (!(ex instanceof ExitStatus)) {
          throw ex;
        }
      });
      process["on"]("unhandledRejection", abort);
      quit_ = function (status) {
        process["exit"](status);
      };
      Module["inspect"] = function () {
        return "[Emscripten Module object]";
      };
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.warn.bind(console);
    for (key in moduleOverrides) {
      if (moduleOverrides.hasOwnProperty(key)) {
        Module[key] = moduleOverrides[key];
      }
    }
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    if (Module["quit"]) quit_ = Module["quit"];
    var STACK_ALIGN = 16;
    function alignMemory(size, factor) {
      if (!factor) factor = STACK_ALIGN;
      return Math.ceil(size / factor) * factor;
    }
    var tempRet0 = 0;
    var setTempRet0 = function (value) {
      tempRet0 = value;
    };
    var getTempRet0 = function () {
      return tempRet0;
    };
    var wasmBinary;
    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
    var noExitRuntime = Module["noExitRuntime"] || true;
    if (typeof WebAssembly !== "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed: " + text);
      }
    }
    function getCFunc(ident) {
      var func = Module["_" + ident];
      assert(
        func,
        "Cannot call unknown function " + ident + ", make sure it is exported"
      );
      return func;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = {
        string: function (str) {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) {
            var len = (str.length << 2) + 1;
            ret = stackAlloc(len);
            stringToUTF8(str, ret, len);
          }
          return ret;
        },
        array: function (arr) {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        },
      };
      function convertReturnValue(ret) {
        if (returnType === "string") return UTF8ToString(ret);
        if (returnType === "boolean") return Boolean(ret);
        return ret;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      ret = convertReturnValue(ret);
      if (stack !== 0) stackRestore(stack);
      return ret;
    }
    function cwrap(ident, returnType, argTypes, opts) {
      argTypes = argTypes || [];
      var numericArgs = argTypes.every(function (type) {
        return type === "number";
      });
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return function () {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    var UTF8Decoder =
      typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
    function UTF8ArrayToString(heap, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(heap.subarray(idx, endPtr));
      } else {
        var str = "";
        while (idx < endPtr) {
          var u0 = heap[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heap[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode(((u0 & 31) << 6) | u1);
            continue;
          }
          var u2 = heap[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
          } else {
            u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
          }
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | (u >> 6);
          heap[outIdx++] = 128 | (u & 63);
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | (u >> 12);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | (u >> 18);
          heap[outIdx++] = 128 | ((u >> 12) & 63);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343)
          u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
        if (u <= 127) ++len;
        else if (u <= 2047) len += 2;
        else if (u <= 65535) len += 3;
        else len += 4;
      }
      return len;
    }
    function writeArrayToMemory(array, buffer) {
      HEAP8.set(array, buffer);
    }
    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }
      if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }
    function alignUp(x, multiple) {
      if (x % multiple > 0) {
        x += multiple - (x % multiple);
      }
      return x;
    }
    var buffer,
      HEAP8,
      HEAPU8,
      HEAP16,
      HEAPU16,
      HEAP32,
      HEAPU32,
      HEAPF32,
      HEAPF64;
    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }
    var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
    var wasmTable;
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    var runtimeExited = false;
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      FS.ignorePermissions = false;
      callRuntimeCallbacks(__ATMAIN__);
    }
    function exitRuntime() {
      runtimeExited = true;
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    Module["preloadedImages"] = {};
    Module["preloadedAudios"] = {};
    function abort(what) {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
      what += "";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    var wasmBinaryFile =
      "data:application/octet-stream;base64,AGFzbQEAAAABjAVPYAF/AX9gAn9/AGACf38Bf2ABfwBgA39/fwF/YAN/f38AYAR/f39/AX9gBH9/f38AYAV/f39/fwF/YAV/f39/fwBgBn9/f39/fwF/YAZ/f39/f38AYAd/f39/f39/AGAIf39/f39/f38Bf2AAAGAAAX9gB39/f39/f38Bf2ACf34AYAl/f39/f39/f38Bf2AIf39/f39/f38AYAp/f39/f39/f39/AX9gBX9+fn5+AGAMf39/f39/f39/f39/AX9gAn98AX9gAX8BfmAEf39/fwF+YAR/fn5+AX9gBn9+fn5+fgF/YAV/f39/fgF/YAF+AX5gBH9+fn8AYAJ/fwF8YAp/f39/f39/f39/AGALf39/f39/f39/f38Bf2AFf35+fn4Bf2AFf39+f38AYAN/f38BfGADf35+AGACf3wAYAJ+fgF+YAJ/fgF/YAF8AX9gAn9/AX5gA39/fgBgAX8BfGADf35/AGAGf3x/f39/AX9gD39/f39/f39/f39/f39/fwBgA39+fwF+YAR/fn5+AGADfn9/AX9gB39/f39/fn4Bf2AGf39/f35+AX9gBX9/f398AX9gBH9/f34AYAN/f3wBf2ADf398AGAJf39/f39/f39/AGAIf398f39/f38Bf2ADf3x/AGASf39/f39/f39/f39/f39/f39/AX9gAn5/AX5gBH5+fn4Bf2ACfn8Bf2ADf39+AX5gAAF+YAd/f35+fn5+AX9gAn5+AXxgBn9/fn5+fgBgA39/fwF9YAR/f39+AX5gAn5+AX1gA35+fgF/YAJ8fwF8YAN8f38Bf2ADf3x/AX9gEX9/f39/f39/f39/f39/f39/AX9gB398f39/f38Bf2ACfH8AAugCOwFhAWEADwFhAWIADwFhAWMAAwFhAWQABAFhAWUABQFhAWYABwFhAWcABgFhAWgAAAFhAWkAAQFhAWoAAgFhAWsACQFhAWwACAFhAW0ACgFhAW4ACwFhAW8AAwFhAXAADAFhAXEAEAFhAXIAAAFhAXMANwFhAXQAEwFhAXUAEgFhAXYADgFhAXcAFAFhAXgADQFhAXkABQFhAXoAAAFhAUEAAgFhAUIAAgFhAUMABAFhAUQAOAFhAUUADgFhAUYAOQFhAUcAAwFhAUgACAFhAUkACAFhAUoACAFhAUsAFgFhAUwAFAFhAU0ABwFhAU4AAwFhAU8ABAFhAVAAAAFhAVEACAFhAVIAAgFhAVMAAgFhAVQABgFhAVUAAAFhAVYAAgFhAVcABAFhAVgAAAFhAVkAFgFhAVoAAAFhAV8AAwFhASQAOgFhAmFhACQBYQJiYQA7AWECY2EADgFhAmRhAAABYQJlYQA8A4cihSIAAAACEQMCBAICAAQAAAUAAAIGAwEBAQIAAgAABAECBAABAgMCAgEEAQUAAAICAgMAAwIDAAMCAAECAAAKAgQAAgEAAAYCAgAABgMFAgQBAgUBAAUGBQMBEQAAAAAAAAAAAAIDAwUBBAMCAwEHAAAAAgEIAR0AAAIDBAICAgIEAQABAAICAgUAAgMABA8BAQABAwABAAAEAwMVAQkCAQUEBQABAwUBAwABAgMJAAAAAwMAEQQAAQMEAQIAAgAAAAABAgEBAgMBAAAAAwICBwIBAwICAgICBAQAAwMABgAAAg4AAAQCAAEAAwECAgAABgsCBAAAAQAEAwAAAgABAQIOBAwMDAEEBgAAAAIABQEBBQMCAQEAAQADAD0DCAcDAgQDAgICAgADAgIeAgEBAAEDAAMEAQABAAAACQwCAQUCAAAAAgEAAQACAAIVAgIHBAEEAAMAAAACAwMEBAEDAwIAAgECAAMAAgAEBQAFAA4DAwYEAAEAAAMHAQUCAwAAAwAAAQAAAAACAQAAAQElBAQAEQUCAAAFAQICAgUABAcDAgQCAgQBAAMFAAICAQIDAAIAAwIRBQACAAECAAAEAggCAgMBABcBAQEFAAADAAAFAgAAAQAAAgEICAYAJgICAAMDAgUABQYJAQYGAgACAgIAAAECBAAAAAMAAwMBAAIAAgAAAAACAQINDQoKBwICAQMCAwMGAQABAgMAAwAFAgICAAAAAQMFAgMAAAIAAgYBAwAAAAIFAwMBJwEDAQEAAQEBAQcHAwEAAwAAAgcQAgcSAgkCBAQFAAUCBgQHAAAAAwICAAAFAwMJAwAAAAIAAgQAAQYCAQUEAAYBAAAHAQAABAMCAgABAAADDwECAAI+BQAAAgQDAQIDAAAGAgEBBggCAQACAAAHAwICAAACAAAAAAABAQAAAgICAAADAAQBAAAEBAEAAwADAwABCwMAAQIDAgACBAYDAwAAAAECBR0DAQ4OAQUCAgMUABQAAgEEHj8GAgMCAA8AAgEBBgIABQEEBAQAAgAFAQABBAEEAQADBgEAAQMCBQcIBgYHBAMFAAIAAAAIAAMAAAAABQQDBgAAAwAABQYEAAEBAAIFBAADAQICBwADAAEDBAQFAgAEBA8EBAEAAAMAAQQDAQEoAQECAgMEAAMAAgMAAgQBAQACAgMEAQUHBQQEAgQBBwIBAwEDAgEBBAUCDAIABQIFAQAAAAAAAgEBAwIBBwEDAAIFBAEEAQMBAQkAAQUABwEBBQUAAAEFAAAEAQMAAAcAAAMBBAYECAIAAwUBAAABAgQDAgAHAA8LBAQCAQICAwEBAwECAgADAAQLAgABAAMBAAUABQADBAQAKQEFAQEAAAEBCwMDAwAABAUAAwMBBwAAAQMBAQMCAgQBAQECAwUAAwQCAgMEAwMBAAMBAgQGAwMGAwMCAwEqK0BBBAIAAQEAAQEACQMEAwEBAAAMBAwCEAIQBgAABiwEAAEDAwIAAAcCDAABAgMEAgIEBAQEBAMCJgECAgADBQQDAQIBAwADAgMAAxAXBAICAgAABQIBAgAAAwEBBwEKAwQDAgIBBQEHAwACAAIAAwACBAEDAAwAAAABBwgCAwAACQACAAABAQoBAQEEAQgGAQAAAAEAAAAAAQUBAxQABAEBAAIAAAMFBgADBA8AAQIAAAQBAgIBBAIBBAQFAwAEAg8DAwICAgMBAQIABAADAAAAAQUAAAMCAgQDBAMBKS0AAAAAAAUDAAMAAgMCAwMCAAIBAgMBAQICAwMBAAQEAgAFAQUBAAABAQIEAQUFBwIBCQAAAAEBAQIAAwEDAgIEAwUBAwQAAwECAQABBAMDAwUBBwMAAgIAAwAEAQEDA0IsAgsFBwUAAgEFEwUAAQADAQQBCAYFAgEDBBYJAAQWCQAHGRUAAQAAQwAECAACBh8GAwEPAQUDAAEKCAUHAgMCAi0BBwQFAgIDAgEEAAUAAwMBAAUDAAUFAwEAAAICBgIBBAwCCAYBDAIFAgsJAwUDBwEFBwUABwEDAQIBAQEBAAMBAQkBAAAAAwQDAAICAAYACAYIAAAHAgEBAgsFBBIHBgUCAgUDBgMBBBIEAQIHCQUFBwUACAYBAQEBAgQDBAIBAAMDAQEACAEAAAAAAgICCQAAAAAFAQAHAAECAwUAAQcCAAAACQcEBQMFAAACAAAAAwMEAQEBCAEEBAICDQADCQADFwMDAQMAAAEBAQECAwAAAQMHAQABAgABBAMCAAIEAAUBAQIAEQADAAAAAwAAAwMBAQUCAwQBAAACAwADAwMBAQIDAAEDAAMAAAAABAMIBgUIBgUCAwEAAwADCAYBCAYBAAMAEwMBAwUGAAADAwICAAMAAAMAAAAAAwMEAwMBAAIABggGAAAAAwECAAEHAQUAAAAAAAADAQIAAQEBAgAAAAUDBQUABQEFAwMDAwMDBAUAAgUAAwMDAQMAAAADAAgDDgICAgICAwIBAgYABgEBBAMJBAQDAwMDAwEBAQAAAwMDAAADAQEAAQEBAgAHAg0DAAICBwABAwICAgAHAAMBBAMBAQMBAwEBAQYCAAMDCQECAQMFAQYCAgMAAQABAQMBAQMEAQYCAwkBBAMDAQIYAQMFBwQBAgMBBgEBAQMBAwECAgMBAwkDAQYBBAMDAQEBAgIABgMBAwEDAgEBAgIEAAEFAgACAAMAAQEAAAInAwEDBQUAAAEAAAMDAUQRFQEDBwIDDg4PAAEBCRMFAgEBBQQBAwEFAwIPAwAAAAgBDQACAwMBAwABAwMBAAQvIAIvIAAAAAEhAQAABQMBIQEBCwkLCwkLCwAMBAMMAwoEByRFGQYKBhkGAwIDAAUZRgAGAAMCAgACBCtHKgcDFR4VSAAAAQEDAAACAAAAAgMAAgUAAgMEBDAAAgUASQIfAAIBBAERB